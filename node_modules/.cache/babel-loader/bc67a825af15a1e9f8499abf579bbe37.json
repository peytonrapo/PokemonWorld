{"ast":null,"code":"import _classCallCheck from\"/Users/peytonrapo/Desktop/projects/PokemonWorld/src/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";import _createClass from\"/Users/peytonrapo/Desktop/projects/PokemonWorld/src/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";import _inherits from\"/Users/peytonrapo/Desktop/projects/PokemonWorld/src/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";import _createSuper from\"/Users/peytonrapo/Desktop/projects/PokemonWorld/src/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";import React,{Component}from'react';import{jsx as _jsx}from\"react/jsx-runtime\";var Grid=/*#__PURE__*/function(_Component){_inherits(Grid,_Component);var _super=_createSuper(Grid);function Grid(props){var _this;_classCallCheck(this,Grid);_this=_super.call(this,props);_this.canvasReference=void 0;_this.redraw=function(){if(_this.canvasReference.current===null){throw new Error(\"Unable to access canvas.\");}var ctx=_this.canvasReference.current.getContext('2d');if(ctx===null){throw new Error(\"Unable to create canvas drawing context.\");}// First, let's clear the existing drawing so we can start fresh:\nctx.clearRect(0,0,_this.props.width,_this.props.height);_this.drawGrid(ctx);if(_this.state.character!==null){ctx.drawImage(_this.state.character,_this.props.location[0],_this.props.location[1],50,50);}};_this.state={character:null// An image object to render into the canvas.\n};_this.canvasReference=/*#__PURE__*/React.createRef();return _this;}_createClass(Grid,[{key:\"componentDidMount\",value:function componentDidMount(){// Since we're saving the image in the state and re-using it any time we\n// redraw the canvas, we only need to load it once, when our component first mounts.\nthis.fetchAndSaveImage();this.redraw();}},{key:\"componentDidUpdate\",value:function componentDidUpdate(){this.fetchAndSaveImage();this.redraw();}},{key:\"fetchAndSaveImage\",value:function fetchAndSaveImage(){var _this2=this;// Creates an Image object, and sets a callback function\n// for when the image is done loading (it might take a while).\nvar avatar=new Image();avatar.onload=function(){_this2.setState({character:avatar});};// Once our callback is set up, we tell the image what file it should\n// load from. This also triggers the loading process.\navatar.src=\"./images/avatar/\"+this.props.direction+\".png\";}},{key:\"drawGrid\",value:function drawGrid(ctx){ctx.beginPath();ctx.moveTo(0,0);ctx.lineTo(this.props.width,0);ctx.lineTo(this.props.width,this.props.height);ctx.lineTo(0,this.props.height);ctx.lineTo(0,0);ctx.stroke();}},{key:\"render\",value:function render(){return/*#__PURE__*/_jsx(\"div\",{id:\"grid\",children:/*#__PURE__*/_jsx(\"canvas\",{ref:this.canvasReference,width:this.props.width,height:this.props.height})});}}]);return Grid;}(Component);export default Grid;","map":{"version":3,"sources":["/Users/peytonrapo/Desktop/projects/PokemonWorld/src/Grid.tsx"],"names":["React","Component","Grid","props","canvasReference","redraw","current","Error","ctx","getContext","clearRect","width","height","drawGrid","state","character","drawImage","location","createRef","fetchAndSaveImage","avatar","Image","onload","setState","src","direction","beginPath","moveTo","lineTo","stroke"],"mappings":"wpBAAA,MAAOA,CAAAA,KAAP,EAAeC,SAAf,KAA+B,OAA/B,C,8CAaMC,CAAAA,I,4FAIF,cAAYC,KAAZ,CAA8B,sCAC1B,uBAAMA,KAAN,EAD0B,MAF9BC,eAE8B,cAkC9BC,MAlC8B,CAkCrB,UAAM,CACX,GAAI,MAAKD,eAAL,CAAqBE,OAArB,GAAiC,IAArC,CAA2C,CACvC,KAAM,IAAIC,CAAAA,KAAJ,CAAU,0BAAV,CAAN,CACH,CACD,GAAMC,CAAAA,GAAG,CAAG,MAAKJ,eAAL,CAAqBE,OAArB,CAA6BG,UAA7B,CAAwC,IAAxC,CAAZ,CACA,GAAID,GAAG,GAAK,IAAZ,CAAkB,CACd,KAAM,IAAID,CAAAA,KAAJ,CAAU,0CAAV,CAAN,CACH,CAED;AACAC,GAAG,CAACE,SAAJ,CAAc,CAAd,CAAiB,CAAjB,CAAoB,MAAKP,KAAL,CAAWQ,KAA/B,CAAsC,MAAKR,KAAL,CAAWS,MAAjD,EAEA,MAAKC,QAAL,CAAcL,GAAd,EACA,GAAI,MAAKM,KAAL,CAAWC,SAAX,GAAyB,IAA7B,CAAmC,CAC/BP,GAAG,CAACQ,SAAJ,CAAc,MAAKF,KAAL,CAAWC,SAAzB,CAAoC,MAAKZ,KAAL,CAAWc,QAAX,CAAoB,CAApB,CAApC,CAA4D,MAAKd,KAAL,CAAWc,QAAX,CAAoB,CAApB,CAA5D,CAAoF,EAApF,CAAwF,EAAxF,EACH,CAEJ,CAnD6B,CAE1B,MAAKH,KAAL,CAAa,CACTC,SAAS,CAAE,IAAO;AADT,CAAb,CAGA,MAAKX,eAAL,cAAuBJ,KAAK,CAACkB,SAAN,EAAvB,CAL0B,aAM7B,C,kDAED,4BAAoB,CAChB;AACA;AACA,KAAKC,iBAAL,GACA,KAAKd,MAAL,GACH,C,kCAED,6BAAqB,CACjB,KAAKc,iBAAL,GACA,KAAKd,MAAL,GACH,C,iCAED,4BAAoB,iBAChB;AACA;AACA,GAAMe,CAAAA,MAAM,CAAG,GAAIC,CAAAA,KAAJ,EAAf,CACAD,MAAM,CAACE,MAAP,CAAgB,UAAM,CAClB,MAAI,CAACC,QAAL,CAAc,CACVR,SAAS,CAAEK,MADD,CAAd,EAGH,CAJD,CAKA;AACA;AACAA,MAAM,CAACI,GAAP,CAAa,mBAAqB,KAAKrB,KAAL,CAAWsB,SAAhC,CAA2C,MAAxD,CACH,C,wBAqBD,kBAASjB,GAAT,CAAwC,CACpCA,GAAG,CAACkB,SAAJ,GACAlB,GAAG,CAACmB,MAAJ,CAAW,CAAX,CAAa,CAAb,EACAnB,GAAG,CAACoB,MAAJ,CAAW,KAAKzB,KAAL,CAAWQ,KAAtB,CAA4B,CAA5B,EACAH,GAAG,CAACoB,MAAJ,CAAW,KAAKzB,KAAL,CAAWQ,KAAtB,CAA6B,KAAKR,KAAL,CAAWS,MAAxC,EACAJ,GAAG,CAACoB,MAAJ,CAAW,CAAX,CAAc,KAAKzB,KAAL,CAAWS,MAAzB,EACAJ,GAAG,CAACoB,MAAJ,CAAW,CAAX,CAAa,CAAb,EACApB,GAAG,CAACqB,MAAJ,GACH,C,sBAID,iBAAS,CACL,mBACI,YAAK,EAAE,CAAC,MAAR,uBACI,eAAQ,GAAG,CAAE,KAAKzB,eAAlB,CAAmC,KAAK,CAAE,KAAKD,KAAL,CAAWQ,KAArD,CAA4D,MAAM,CAAE,KAAKR,KAAL,CAAWS,MAA/E,EADJ,EADJ,CAKH,C,kBA3EcX,S,EA8EnB,cAAeC,CAAAA,IAAf","sourcesContent":["import React, {Component} from 'react';\n\ninterface GridProps {\n    width: number;   // width of the canvas on which to draw\n    height: number;  // height of the canvas on which to draw\n    location: [number, number];\n    direction: string;\n}\n\ninterface GridState {\n    character: any;  // image object rendered into the canvas (once loaded)\n}\n\nclass Grid extends Component<GridProps, GridState> {\n\n    canvasReference: React.RefObject<HTMLCanvasElement>\n\n    constructor(props: GridProps) {\n        super(props);\n        this.state = {\n            character: null,  // An image object to render into the canvas.\n        };\n        this.canvasReference = React.createRef();\n    }\n\n    componentDidMount() {\n        // Since we're saving the image in the state and re-using it any time we\n        // redraw the canvas, we only need to load it once, when our component first mounts.\n        this.fetchAndSaveImage();\n        this.redraw();\n    }\n\n    componentDidUpdate() {\n        this.fetchAndSaveImage();\n        this.redraw();\n    }\n\n    fetchAndSaveImage() {\n        // Creates an Image object, and sets a callback function\n        // for when the image is done loading (it might take a while).\n        const avatar = new Image();\n        avatar.onload = () => {\n            this.setState({\n                character: avatar\n            });\n        };\n        // Once our callback is set up, we tell the image what file it should\n        // load from. This also triggers the loading process.\n        avatar.src = \"./images/avatar/\" + this.props.direction +\".png\";\n    }\n\n    redraw = () => {\n        if (this.canvasReference.current === null) {\n            throw new Error(\"Unable to access canvas.\");\n        }\n        const ctx = this.canvasReference.current.getContext('2d');\n        if (ctx === null) {\n            throw new Error(\"Unable to create canvas drawing context.\");\n        }\n\n        // First, let's clear the existing drawing so we can start fresh:\n        ctx.clearRect(0, 0, this.props.width, this.props.height);\n\n        this.drawGrid(ctx);\n        if (this.state.character !== null) {\n            ctx.drawImage(this.state.character, this.props.location[0], this.props.location[1], 50, 50);\n        }\n\n    };\n\n    drawGrid(ctx: CanvasRenderingContext2D) {\n        ctx.beginPath();\n        ctx.moveTo(0,0);\n        ctx.lineTo(this.props.width,0);\n        ctx.lineTo(this.props.width, this.props.height);\n        ctx.lineTo(0, this.props.height);\n        ctx.lineTo(0,0);\n        ctx.stroke();\n    }\n\n\n\n    render() {\n        return (\n            <div id=\"grid\">\n                <canvas ref={this.canvasReference} width={this.props.width} height={this.props.height}/>\n            </div>\n        );\n    }\n}\n\nexport default Grid;"]},"metadata":{},"sourceType":"module"}