{"version":3,"sources":["Grid.tsx","App.tsx","index.tsx"],"names":["Grid","props","canvasReference","redraw","current","Error","ctx","getContext","clearRect","width","height","drawGrid","state","character","drawImage","location","React","createRef","this","fetchAndSaveImage","avatar","Image","onload","setState","src","direction","beginPath","moveTo","lineTo","stroke","id","ref","Component","App","handleMovement","event","key","canvasSize","onKeyPress","ReactDOM","render","document","getElementById"],"mappings":"mMA2FeA,E,kDA1EX,WAAYC,GAAmB,IAAD,8BAC1B,cAAMA,IAHVC,qBAE8B,IAkC9BC,OAAS,WACL,GAAqC,OAAjC,EAAKD,gBAAgBE,QACrB,MAAM,IAAIC,MAAM,4BAEpB,IAAMC,EAAM,EAAKJ,gBAAgBE,QAAQG,WAAW,MACpD,GAAY,OAARD,EACA,MAAM,IAAID,MAAM,4CAIpBC,EAAIE,UAAU,EAAG,EAAG,EAAKP,MAAMQ,MAAO,EAAKR,MAAMS,QAEjD,EAAKC,SAASL,GACe,OAAzB,EAAKM,MAAMC,WACXP,EAAIQ,UAAU,EAAKF,MAAMC,UAAW,EAAKZ,MAAMc,SAAS,GAAI,EAAKd,MAAMc,SAAS,GAAI,GAAI,KA9C5F,EAAKH,MAAQ,CACTC,UAAW,MAEf,EAAKX,gBAAkBc,IAAMC,YALH,E,qDAQ9B,WAGIC,KAAKC,oBACLD,KAAKf,W,gCAGT,WACIe,KAAKC,oBACLD,KAAKf,W,+BAGT,WAAqB,IAAD,OAGViB,EAAS,IAAIC,MACnBD,EAAOE,OAAS,WACZ,EAAKC,SAAS,CACVV,UAAWO,KAKnBA,EAAOI,IAAM,mBAAqBN,KAAKjB,MAAMwB,UAAW,S,sBAsB5D,SAASnB,GACLA,EAAIoB,YACJpB,EAAIqB,OAAO,EAAE,GACbrB,EAAIsB,OAAOV,KAAKjB,MAAMQ,MAAM,GAC5BH,EAAIsB,OAAOV,KAAKjB,MAAMQ,MAAOS,KAAKjB,MAAMS,QACxCJ,EAAIsB,OAAO,EAAGV,KAAKjB,MAAMS,QACzBJ,EAAIsB,OAAO,EAAE,GACbtB,EAAIuB,W,oBAKR,WACI,OACI,qBAAKC,GAAG,OAAR,SACI,wBAAQC,IAAKb,KAAKhB,gBAAiBO,MAAOS,KAAKjB,MAAMQ,MAAOC,OAAQQ,KAAKjB,MAAMS,e,GAxE5EsB,aC+CJC,E,kDAlDX,WAAYhC,GAAa,IAAD,8BACpB,cAAMA,IAQViC,eAAiB,SAACC,GACG,MAAdA,EAAMC,IACD,EAAKxB,MAAMG,UACf,EAAKQ,SAAS,CACVR,SAAU,CAAC,EAAKH,MAAMG,SAAS,GAAI,EAAKH,MAAMG,SAAS,GAAK,IAC5DU,UAAW,SAGI,MAAdU,EAAMC,IACX,EAAKb,SAAS,CACVR,SAAU,CAAC,EAAKH,MAAMG,SAAS,GAAG,EAAKH,MAAMG,SAAS,GAAK,IAC3DU,UAAW,UAGI,MAAdU,EAAMC,IACX,EAAKb,SAAS,CACVR,SAAU,CAAC,EAAKH,MAAMG,SAAS,GAAK,GAAI,EAAKH,MAAMG,SAAS,IAC5DU,UAAW,SAGI,MAAdU,EAAMC,KACX,EAAKb,SAAS,CACVR,SAAU,CAAC,EAAKH,MAAMG,SAAS,GAAK,GAAI,EAAKH,MAAMG,SAAS,IAC5DU,UAAW,WA9BnB,EAAKb,MAAQ,CACTG,SAAU,CAAC,IAAK,KAChBsB,WAAY,IACZZ,UAAW,SALK,E,0CAqCxB,WAEI,OACI,gCACI,+CACA,cAAC,EAAD,CAAMhB,MAJM,IAIcC,OAJd,IAImCK,SAAUG,KAAKN,MAAMG,SAAUU,UAAWP,KAAKN,MAAMa,YACpG,0BAAUa,WAAYpB,KAAKgB,wB,GA5CzBF,aCLlBO,IAASC,OAAO,cAAC,EAAD,IAASC,SAASC,eAAe,W","file":"static/js/main.ba0761fe.chunk.js","sourcesContent":["import React, {Component} from 'react';\n\ninterface GridProps {\n    width: number;   // width of the canvas on which to draw\n    height: number;  // height of the canvas on which to draw\n    location: [number, number];\n    direction: string;\n}\n\ninterface GridState {\n    character: any;  // image object rendered into the canvas (once loaded)\n}\n\nclass Grid extends Component<GridProps, GridState> {\n\n    canvasReference: React.RefObject<HTMLCanvasElement>\n\n    constructor(props: GridProps) {\n        super(props);\n        this.state = {\n            character: null,  // An image object to render into the canvas.\n        };\n        this.canvasReference = React.createRef();\n    }\n\n    componentDidMount() {\n        // Since we're saving the image in the state and re-using it any time we\n        // redraw the canvas, we only need to load it once, when our component first mounts.\n        this.fetchAndSaveImage();\n        this.redraw();\n    }\n\n    componentDidUpdate() {\n        this.fetchAndSaveImage();\n        this.redraw();\n    }\n\n    fetchAndSaveImage() {\n        // Creates an Image object, and sets a callback function\n        // for when the image is done loading (it might take a while).\n        const avatar = new Image();\n        avatar.onload = () => {\n            this.setState({\n                character: avatar\n            });\n        };\n        // Once our callback is set up, we tell the image what file it should\n        // load from. This also triggers the loading process.\n        avatar.src = \"./images/avatar/\" + this.props.direction +\".png\";\n    }\n\n    redraw = () => {\n        if (this.canvasReference.current === null) {\n            throw new Error(\"Unable to access canvas.\");\n        }\n        const ctx = this.canvasReference.current.getContext('2d');\n        if (ctx === null) {\n            throw new Error(\"Unable to create canvas drawing context.\");\n        }\n\n        // First, let's clear the existing drawing so we can start fresh:\n        ctx.clearRect(0, 0, this.props.width, this.props.height);\n\n        this.drawGrid(ctx);\n        if (this.state.character !== null) {\n            ctx.drawImage(this.state.character, this.props.location[0], this.props.location[1], 50, 50);\n        }\n\n    };\n\n    drawGrid(ctx: CanvasRenderingContext2D) {\n        ctx.beginPath();\n        ctx.moveTo(0,0);\n        ctx.lineTo(this.props.width,0);\n        ctx.lineTo(this.props.width, this.props.height);\n        ctx.lineTo(0, this.props.height);\n        ctx.lineTo(0,0);\n        ctx.stroke();\n    }\n\n\n\n    render() {\n        return (\n            <div id=\"grid\">\n                <canvas ref={this.canvasReference} width={this.props.width} height={this.props.height}/>\n            </div>\n        );\n    }\n}\n\nexport default Grid;","import React, {Component} from 'react';\nimport Grid from \"./Grid\";\n\ninterface AppState {\n    location: [number, number] // x, y\n    direction: string\n    canvasSize: number\n}\n\nclass App extends Component<{}, AppState> {\n    constructor(props: any) {\n        super(props);\n        this.state = {\n            location: [400, 400],\n            canvasSize: 800,\n            direction: \"front\"\n        };\n    }\n\n    handleMovement = (event: { key: string; }) => {\n        if(event.key === 'w'){ // go up 1\n            if (this.state.location)\n            this.setState({\n                location: [this.state.location[0] ,this.state.location[1] - 10],\n                direction: \"back\"\n            });\n        }\n        else if (event.key === 's') { // go down one\n            this.setState({\n                location: [this.state.location[0],this.state.location[1] + 10],\n                direction: \"front\"\n            });\n        }\n        else if (event.key === 'a') { // go left 1\n            this.setState({\n                location: [this.state.location[0] - 10, this.state.location[1]],\n                direction: \"left\"\n            });\n        }\n        else if (event.key === 'd') { // go right 1\n            this.setState({\n                location: [this.state.location[0] + 10, this.state.location[1]],\n                direction: \"right\"\n            });\n        }\n    }\n\n    render() {\n        const canvas_size = 800;\n        return (\n            <div>\n                <h1>Pokemon World</h1>\n                <Grid width={canvas_size} height={canvas_size} location={this.state.location} direction={this.state.direction}/>\n                <textarea onKeyPress={this.handleMovement}/>\n            </div>\n        );\n    }\n\n}\n\nexport default App;","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nReactDOM.render(<App />, document.getElementById('root'));\n"],"sourceRoot":""}