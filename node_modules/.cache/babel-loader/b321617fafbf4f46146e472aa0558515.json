{"ast":null,"code":"var _jsxFileName = \"/Users/peytonrapo/Desktop/projects/PokemonWorld/src/Grid.tsx\";\nimport React, { Component } from 'react';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nclass Grid extends Component {\n  constructor(props) {\n    super(props);\n    this.canvasReference = void 0;\n\n    this.redraw = () => {\n      if (this.canvasReference.current === null) {\n        throw new Error(\"Unable to access canvas.\");\n      }\n\n      const ctx = this.canvasReference.current.getContext('2d');\n\n      if (ctx === null) {\n        throw new Error(\"Unable to create canvas drawing context.\");\n      } // First, let's clear the existing drawing so we can start fresh:\n\n\n      ctx.clearRect(0, 0, this.props.width, this.props.height);\n      this.drawGrid(ctx);\n\n      if (this.state.character !== null) {\n        ctx.drawImage(this.state.character, 0, 0);\n      }\n    };\n\n    this.state = {\n      character: null // An image object to render into the canvas.\n\n    };\n    this.canvasReference = /*#__PURE__*/React.createRef();\n  }\n\n  componentDidMount() {\n    // Since we're saving the image in the state and re-using it any time we\n    // redraw the canvas, we only need to load it once, when our component first mounts.\n    this.fetchAndSaveImage();\n    this.redraw();\n  }\n\n  componentDidUpdate() {\n    this.redraw();\n  }\n\n  fetchAndSaveImage() {\n    // Creates an Image object, and sets a callback function\n    // for when the image is done loading (it might take a while).\n    const avatar = new Image();\n\n    avatar.onload = () => {\n      this.setState({\n        character: avatar\n      });\n    }; // Once our callback is set up, we tell the image what file it should\n    // load from. This also triggers the loading process.\n\n\n    avatar.src = \"avatar.png\";\n  }\n\n  drawGrid(ctx) {\n    ctx.beginPath();\n    ctx.moveTo(0, 0);\n    ctx.lineTo(this.props.width, 0);\n    ctx.lineTo(this.props.width, this.props.height);\n    ctx.lineTo(0, this.props.height);\n    ctx.lineTo(0, 0);\n    ctx.stroke();\n  }\n\n  render() {\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      id: \"grid\",\n      children: /*#__PURE__*/_jsxDEV(\"canvas\", {\n        ref: this.canvasReference,\n        width: this.props.width,\n        height: this.props.height\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 83,\n        columnNumber: 17\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 82,\n      columnNumber: 13\n    }, this);\n  }\n\n}\n\nexport default Grid;","map":{"version":3,"sources":["/Users/peytonrapo/Desktop/projects/PokemonWorld/src/Grid.tsx"],"names":["React","Component","Grid","constructor","props","canvasReference","redraw","current","Error","ctx","getContext","clearRect","width","height","drawGrid","state","character","drawImage","createRef","componentDidMount","fetchAndSaveImage","componentDidUpdate","avatar","Image","onload","setState","src","beginPath","moveTo","lineTo","stroke","render"],"mappings":";AAAA,OAAOA,KAAP,IAAeC,SAAf,QAA+B,OAA/B;;;AAYA,MAAMC,IAAN,SAAmBD,SAAnB,CAAmD;AAI/CE,EAAAA,WAAW,CAACC,KAAD,EAAmB;AAC1B,UAAMA,KAAN;AAD0B,SAF9BC,eAE8B;;AAAA,SAiC9BC,MAjC8B,GAiCrB,MAAM;AACX,UAAI,KAAKD,eAAL,CAAqBE,OAArB,KAAiC,IAArC,EAA2C;AACvC,cAAM,IAAIC,KAAJ,CAAU,0BAAV,CAAN;AACH;;AACD,YAAMC,GAAG,GAAG,KAAKJ,eAAL,CAAqBE,OAArB,CAA6BG,UAA7B,CAAwC,IAAxC,CAAZ;;AACA,UAAID,GAAG,KAAK,IAAZ,EAAkB;AACd,cAAM,IAAID,KAAJ,CAAU,0CAAV,CAAN;AACH,OAPU,CASX;;;AACAC,MAAAA,GAAG,CAACE,SAAJ,CAAc,CAAd,EAAiB,CAAjB,EAAoB,KAAKP,KAAL,CAAWQ,KAA/B,EAAsC,KAAKR,KAAL,CAAWS,MAAjD;AACA,WAAKC,QAAL,CAAcL,GAAd;;AAEA,UAAI,KAAKM,KAAL,CAAWC,SAAX,KAAyB,IAA7B,EAAmC;AAC/BP,QAAAA,GAAG,CAACQ,SAAJ,CAAc,KAAKF,KAAL,CAAWC,SAAzB,EAAoC,CAApC,EAAuC,CAAvC;AACH;AACJ,KAjD6B;;AAE1B,SAAKD,KAAL,GAAa;AACTC,MAAAA,SAAS,EAAE,IADF,CACS;;AADT,KAAb;AAGA,SAAKX,eAAL,gBAAuBL,KAAK,CAACkB,SAAN,EAAvB;AACH;;AAEDC,EAAAA,iBAAiB,GAAG;AAChB;AACA;AACA,SAAKC,iBAAL;AACA,SAAKd,MAAL;AACH;;AAEDe,EAAAA,kBAAkB,GAAG;AACjB,SAAKf,MAAL;AACH;;AAEDc,EAAAA,iBAAiB,GAAG;AAChB;AACA;AACA,UAAME,MAAM,GAAG,IAAIC,KAAJ,EAAf;;AACAD,IAAAA,MAAM,CAACE,MAAP,GAAgB,MAAM;AAClB,WAAKC,QAAL,CAAc;AACVT,QAAAA,SAAS,EAAEM;AADD,OAAd;AAGH,KAJD,CAJgB,CAShB;AACA;;;AACAA,IAAAA,MAAM,CAACI,GAAP,GAAa,YAAb;AACH;;AAoBDZ,EAAAA,QAAQ,CAACL,GAAD,EAAgC;AACpCA,IAAAA,GAAG,CAACkB,SAAJ;AACAlB,IAAAA,GAAG,CAACmB,MAAJ,CAAW,CAAX,EAAa,CAAb;AACAnB,IAAAA,GAAG,CAACoB,MAAJ,CAAW,KAAKzB,KAAL,CAAWQ,KAAtB,EAA4B,CAA5B;AACAH,IAAAA,GAAG,CAACoB,MAAJ,CAAW,KAAKzB,KAAL,CAAWQ,KAAtB,EAA6B,KAAKR,KAAL,CAAWS,MAAxC;AACAJ,IAAAA,GAAG,CAACoB,MAAJ,CAAW,CAAX,EAAc,KAAKzB,KAAL,CAAWS,MAAzB;AACAJ,IAAAA,GAAG,CAACoB,MAAJ,CAAW,CAAX,EAAa,CAAb;AACApB,IAAAA,GAAG,CAACqB,MAAJ;AACH;;AAIDC,EAAAA,MAAM,GAAG;AACL,wBACI;AAAK,MAAA,EAAE,EAAC,MAAR;AAAA,6BACI;AAAQ,QAAA,GAAG,EAAE,KAAK1B,eAAlB;AAAmC,QAAA,KAAK,EAAE,KAAKD,KAAL,CAAWQ,KAArD;AAA4D,QAAA,MAAM,EAAE,KAAKR,KAAL,CAAWS;AAA/E;AAAA;AAAA;AAAA;AAAA;AADJ;AAAA;AAAA;AAAA;AAAA,YADJ;AAKH;;AAzE8C;;AA4EnD,eAAeX,IAAf","sourcesContent":["import React, {Component} from 'react';\n\ninterface GridProps {\n    width: number;   // width of the canvas on which to draw\n    height: number;  // height of the canvas on which to draw\n    location: [number, number];\n}\n\ninterface GridState {\n    character: any;  // image object rendered into the canvas (once loaded)\n}\n\nclass Grid extends Component<GridProps, GridState> {\n\n    canvasReference: React.RefObject<HTMLCanvasElement>\n\n    constructor(props: GridProps) {\n        super(props);\n        this.state = {\n            character: null,  // An image object to render into the canvas.\n        };\n        this.canvasReference = React.createRef();\n    }\n\n    componentDidMount() {\n        // Since we're saving the image in the state and re-using it any time we\n        // redraw the canvas, we only need to load it once, when our component first mounts.\n        this.fetchAndSaveImage();\n        this.redraw();\n    }\n\n    componentDidUpdate() {\n        this.redraw();\n    }\n\n    fetchAndSaveImage() {\n        // Creates an Image object, and sets a callback function\n        // for when the image is done loading (it might take a while).\n        const avatar = new Image();\n        avatar.onload = () => {\n            this.setState({\n                character: avatar\n            });\n        };\n        // Once our callback is set up, we tell the image what file it should\n        // load from. This also triggers the loading process.\n        avatar.src = \"avatar.png\";\n    }\n\n    redraw = () => {\n        if (this.canvasReference.current === null) {\n            throw new Error(\"Unable to access canvas.\");\n        }\n        const ctx = this.canvasReference.current.getContext('2d');\n        if (ctx === null) {\n            throw new Error(\"Unable to create canvas drawing context.\");\n        }\n\n        // First, let's clear the existing drawing so we can start fresh:\n        ctx.clearRect(0, 0, this.props.width, this.props.height);\n        this.drawGrid(ctx);\n\n        if (this.state.character !== null) {\n            ctx.drawImage(this.state.character, 0, 0);\n        }\n    };\n\n    drawGrid(ctx: CanvasRenderingContext2D) {\n        ctx.beginPath();\n        ctx.moveTo(0,0);\n        ctx.lineTo(this.props.width,0);\n        ctx.lineTo(this.props.width, this.props.height);\n        ctx.lineTo(0, this.props.height);\n        ctx.lineTo(0,0);\n        ctx.stroke();\n    }\n\n\n\n    render() {\n        return (\n            <div id=\"grid\">\n                <canvas ref={this.canvasReference} width={this.props.width} height={this.props.height}/>\n            </div>\n        );\n    }\n}\n\nexport default Grid;"]},"metadata":{},"sourceType":"module"}